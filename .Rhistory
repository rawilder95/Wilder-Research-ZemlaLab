zName="Hits", NName="AtBats", sName="Dogname", cName="TrainerType",
numSavedSteps=11000 , saveName=fileNameRoot ,
thinSteps=20 )
myData
colnames(myData)
# Read the data
myData
# Prior to R 4.0, read.csv() produced strings as factors. With R 4.0+, strings
# must be explicitly set as factors if desired:
myData$TrainerType = factor(myData$TrainerType)
myData$Dogname = factor(myData$Dogname)
#-------------------------------------------------------------------------------
# Load the relevant model into R's working memory:
source("Jags-Ybinom-XnomSsubjCcat-MbinomBetaOmegaKappa.R")
#-------------------------------------------------------------------------------
# Optional: Specify filename root and graphical format for saving output.
# Otherwise specify as NULL or leave saveName and saveType arguments
# out of function calls.
fileNameRoot = "dog-training"
graphFileType = "png"
#-------------------------------------------------------------------------------
# Generate the MCMC chain:
startTime = proc.time()
mcmcCoda = genMCMC( data=myData ,
zName="Outcome", NName="Group", sName="Dogname", cName="TrainerType",
numSavedSteps=11000 , saveName=fileNameRoot ,
thinSteps=20 )
# Read the data
myData
# Prior to R 4.0, read.csv() produced strings as factors. With R 4.0+, strings
# must be explicitly set as factors if desired:
myData$TrainerType = factor(myData$TrainerType)
myData$Dogname = factor(myData$Dogname)
#-------------------------------------------------------------------------------
# Load the relevant model into R's working memory:
source("Jags-Ybinom-XnomSsubjCcat-MbinomBetaOmegaKappa.R")
#-------------------------------------------------------------------------------
# Optional: Specify filename root and graphical format for saving output.
# Otherwise specify as NULL or leave saveName and saveType arguments
# out of function calls.
fileNameRoot = "dog-training"
graphFileType = "png"
#-------------------------------------------------------------------------------
# Generate the MCMC chain:
startTime = proc.time()
mcmcCoda = genMCMC( data=myData ,
zName="Outcome", NName="Group", sName="Dogname", cName="TrainerType",
numSavedSteps=11000 , saveName=fileNameRoot ,
thinSteps=20 )
? dump.format
getwd()
if (getwd()!= "/Users/rebeccawilder/Desktop/BayesStatsFall21/DBDA2Eprograms"){
setwd("~/Desktop/BayesStatsFall21/DBDA2Eprograms")
}
# install.packages("knitr-package")
library("readxl")
library(readxl)
install.packages("tidyverse")
myData = read.csv("dogTrainingData.csv")
library(tidyverse)
myData <- mutate(myData, Outcome= case_when(Outcome== "Worse" ~0, Outcome== "Same"~0, Outcome== "Better "~1))
myData
yName = "Outcome" # column name for 0,1 values
sName = "Dogname" # column name for subject ID
# Optional: Specify filename root and graphical format for saving output.
# Otherwise specify as NULL or leave saveName and saveType arguments
# out of function calls.
fileNameRoot = "Jags-Ydich-XnomSsubj-MbernBetaOmegaKappa-"
graphFileType = "png"
#-------------------------------------------------------------------------------
# # Read The data file:
# myData = read.csv("StormTressoldiDiRisio2010data.csv")
# yName = "Correct" # column name for 0,1 values
# sName = "Study" # column name for "subject" ID
# # Optional: Specify filename root and graphical format for saving output.
# # Otherwise specify as NULL or leave saveName and saveType arguments
# # out of function calls.
# fileNameRoot = "StormTressoldiDiRisio2010-"
# graphFileType = "eps"
#-------------------------------------------------------------------------------
# Load the relevant model into R's working memory:
source("Jags-Ydich-XnomSsubj-MbernBetaOmegaKappa.R")
#-------------------------------------------------------------------------------
# Generate the MCMC chain:
mcmcCoda = genMCMC( data=myData , sName=sName , yName=yName ,
numSavedSteps=20000 , saveName=fileNameRoot , thinSteps=10 )
#-------------------------------------------------------------------------------
# Display diagnostics of chain, for specified parameters:
parameterNames = varnames(mcmcCoda) # get all parameter names for reference
for ( parName in parameterNames[c(1:2,length(parameterNames))] ) {
diagMCMC( codaObject=mcmcCoda , parName=parName ,
saveName=fileNameRoot , saveType=graphFileType )
}
#-------------------------------------------------------------------------------
# Get summary statistics of chain:
summaryInfo = smryMCMC( mcmcCoda , compVal=0.5 ,
diffIdVec=c(1,14,28),  # Therapeutic touch
# diffIdVec=c(38,60,2),  # ESP Tressoldi et al.
compValDiff=0.0 ,
saveName=fileNameRoot )
# Display posterior information:
plotMCMC( mcmcCoda , data=myData , sName=sName , yName=yName ,
compVal=0.5 , #rope=c(0.45,0.55) , # Therapeutic touch
diffIdVec=c(1,14,28),              # Therapeutic touch
# compVal=0.25 , #rope=c(0.22,0.28) , # ESP Tressoldi et al.
# diffIdVec=c(38,60,2),               # ESP Tressoldi et al.
compValDiff=0.0, #ropeDiff = c(-0.05,0.05) ,
saveName=fileNameRoot , saveType=graphFileType )
#-------------------------------------------------------------------------------
yName = "Outcome" # column name for 0,1 values
sName = "Dogname" # column name for subject ID
# Optional: Specify filename root and graphical format for saving output.
# Otherwise specify as NULL or leave saveName and saveType arguments
# out of function calls.
fileNameRoot = "Jags-Ydich-XnomSsubj-MbernBetaOmegaKappa-"
graphFileType = "png"
#-------------------------------------------------------------------------------
# # Read The data file:
# myData = read.csv("StormTressoldiDiRisio2010data.csv")
# yName = "Correct" # column name for 0,1 values
# sName = "Study" # column name for "subject" ID
# # Optional: Specify filename root and graphical format for saving output.
# # Otherwise specify as NULL or leave saveName and saveType arguments
# # out of function calls.
# fileNameRoot = "StormTressoldiDiRisio2010-"
# graphFileType = "eps"
#-------------------------------------------------------------------------------
# Load the relevant model into R's working memory:
source("Jags-Ydich-XnomSsubj-MbernBetaOmegaKappa.R")
#-------------------------------------------------------------------------------
# Generate the MCMC chain:
mcmcCoda = genMCMC( data=myData , sName=sName , yName=yName ,
numSavedSteps=20000 , saveName=fileNameRoot , thinSteps=10 )
#-------------------------------------------------------------------------------
# Display diagnostics of chain, for specified parameters:
parameterNames = varnames(mcmcCoda) # get all parameter names for reference
for ( parName in parameterNames[c(1:2,length(parameterNames))] ) {
diagMCMC( codaObject=mcmcCoda , parName=parName ,
saveName=fileNameRoot , saveType=graphFileType )
}
#-------------------------------------------------------------------------------
# Get summary statistics of chain:
summaryInfo = smryMCMC( mcmcCoda , compVal=0.5 ,
diffIdVec=c(1,14,28),  # Therapeutic touch
# diffIdVec=c(38,60,2),  # ESP Tressoldi et al.
compValDiff=0.0 ,
saveName=fileNameRoot )
# Display posterior information:
plotMCMC( mcmcCoda , data=myData , sName=sName , yName=yName ,
compVal=0.5 , #rope=c(0.45,0.55) , # Therapeutic touch
diffIdVec=c(1, 5, 7 12, 15, 38),              # Therapeutic touch
plotMCMC( mcmcCoda , data=myData , sName=sName , yName=yName ,
compVal=0.5 , #rope=c(0.45,0.55) , # Therapeutic touch
diffIdVec=c(1, 5, 7, 12, 15, 38),              # Therapeutic touch
# compVal=0.25 , #rope=c(0.22,0.28) , # ESP Tressoldi et al.
# diffIdVec=c(38,60,2),               # ESP Tressoldi et al.
compValDiff=0.0, #ropeDiff = c(-0.05,0.05) ,
saveName=fileNameRoot , saveType=graphFileType )
# Read the data
myData
# Prior to R 4.0, read.csv() produced strings as factors. With R 4.0+, strings
# must be explicitly set as factors if desired:
myData$TrainerType = factor(myData$TrainerType)
myData$Dogname = factor(myData$Dogname)
#-------------------------------------------------------------------------------
# Load the relevant model into R's working memory:
source("Jags-Ybinom-XnomSsubjCcat-MbinomBetaOmegaKappa.R")
#-------------------------------------------------------------------------------
# Optional: Specify filename root and graphical format for saving output.
# Otherwise specify as NULL or leave saveName and saveType arguments
# out of function calls.
fileNameRoot = "dog-training"
graphFileType = "png"
#-------------------------------------------------------------------------------
# Generate the MCMC chain:
startTime = proc.time()
mcmcCoda = genMCMC( data=myData ,
zName="Outcome", NName="Group", sName="Group", cName="TrainerType",
numSavedSteps=11000 , saveName=fileNameRoot ,
thinSteps=20 )
# Read the data
myData
# Prior to R 4.0, read.csv() produced strings as factors. With R 4.0+, strings
# must be explicitly set as factors if desired:
myData$TrainerType = factor(myData$TrainerType)
myData$Dogname = factor(myData$Dogname)
myData$Group = factor(myData$Group)
#-------------------------------------------------------------------------------
# Load the relevant model into R's working memory:
source("Jags-Ybinom-XnomSsubjCcat-MbinomBetaOmegaKappa.R")
#-------------------------------------------------------------------------------
# Optional: Specify filename root and graphical format for saving output.
# Otherwise specify as NULL or leave saveName and saveType arguments
# out of function calls.
fileNameRoot = "dog-training"
graphFileType = "png"
#-------------------------------------------------------------------------------
# Generate the MCMC chain:
startTime = proc.time()
mcmcCoda = genMCMC( data=myData ,
zName="Outcome", NName="Group", sName="Group", cName="TrainerType",
numSavedSteps=11000 , saveName=fileNameRoot ,
thinSteps=20 )
myData
myData$TrainerType = factor(myData$TrainerType)
myData$Dogname = factor(myData$Dogname)
myData$Group = factor(myData$Group)
factor(myData$Group)
# Read the data
myData
# Prior to R 4.0, read.csv() produced strings as factors. With R 4.0+, strings
# must be explicitly set as factors if desired:
myData$TrainerType = factor(myData$TrainerType)
myData$Dogname = factor(myData$Dogname)
myData$Group = factor(myData$Group)
#-------------------------------------------------------------------------------
# Load the relevant model into R's working memory:
source("Jags-Ybinom-XnomSsubjCcat-MbinomBetaOmegaKappa.R")
#-------------------------------------------------------------------------------
# Optional: Specify filename root and graphical format for saving output.
# Otherwise specify as NULL or leave saveName and saveType arguments
# out of function calls.
fileNameRoot = "dog-training"
graphFileType = "png"
#-------------------------------------------------------------------------------
# Generate the MCMC chain:
startTime = proc.time()
mcmcCoda = genMCMC( data=myData ,
zName="Outcome", NName="Group", sName="Group", cName="TrainerType",
numSavedSteps=11000 , saveName=fileNameRoot ,
thinSteps=20 )
# Example for Jags-Ybinom-XnomSsubjCcat-MbinomBetaOmegaKappa.R
#-------------------------------------------------------------------------------
# Optional generic preliminaries:
graphics.off() # This closes all of R's graphics windows.
rm(list=ls())  # Careful! This clears all of R's memory!
#-------------------------------------------------------------------------------
# Read the data
myData = read.csv("BattingAverage.csv")
# Prior to R 4.0, read.csv() produced strings as factors. With R 4.0+, strings
# must be explicitly set as factors if desired:
myData$PriPos = factor(myData$PriPos)
myData$Player = factor(myData$Player)
#-------------------------------------------------------------------------------
# Load the relevant model into R's working memory:
source("Jags-Ybinom-XnomSsubjCcat-MbinomBetaOmegaKappa.R")
#-------------------------------------------------------------------------------
# Optional: Specify filename root and graphical format for saving output.
# Otherwise specify as NULL or leave saveName and saveType arguments
# out of function calls.
fileNameRoot = "BattingAverage-POST-"
graphFileType = "eps"
#-------------------------------------------------------------------------------
# Generate the MCMC chain:
startTime = proc.time()
mcmcCoda = genMCMC( data=myData ,
zName="Hits", NName="AtBats", sName="Player", cName="PriPos",
numSavedSteps=11000 , saveName=fileNameRoot ,
thinSteps=20 )
stopTime = proc.time()
elapsedTime = stopTime - startTime
show(elapsedTime)
#-------------------------------------------------------------------------------
# Display diagnostics of chain, for specified parameters:
parameterNames = varnames(mcmcCoda) # get all parameter names for reference
for ( parName in c("omega[1]","omegaO","kappa[1]","kappaO","theta[1]") ) {
diagMCMC( codaObject=mcmcCoda , parName=parName ,
saveName=fileNameRoot , saveType=graphFileType )
}
#-------------------------------------------------------------------------------
# Get summary statistics of chain:
summaryInfo = smryMCMC( mcmcCoda , compVal=NULL ,
diffSVec=c(75,156, 159,844) ,
diffCVec=c(1,2,3) ,
compValDiff=0.0 , saveName=fileNameRoot )
# Display posterior information:
plotMCMC( mcmcCoda , data=myData ,
zName="Hits", NName="AtBats", sName="Player", cName="PriPos",
compVal=NULL ,
diffCList=list( c("Pitcher","Catcher") ,
c("Catcher","1st Base") ) ,
diffSList=list( c("Kyle Blanks","Bruce Chen") ,
c("Mike Leake","Wandy Rodriguez") ,
c("Andrew McCutchen","Brett Jackson") ,
c("ShinSoo Choo","Ichiro Suzuki") ) ,
compValDiff=0.0, #ropeDiff = c(-0.05,0.05) ,
saveName=fileNameRoot , saveType=graphFileType )
if (getwd()!= "/Users/rebeccawilder/Desktop/Research 2021-2022"){
setwd("~/Desktop//Research 2021-2022")
}
# install.packages("data.table")
library(data.table)
library(ggplot2)
dat <- data.table(read.csv("snafu_sample.csv"))
(dat <- dat[dat[,group == "Experiment1"]])
if (getwd()!= "/Users/rebeccawilder/Desktop/Research 2021-2022"){
setwd("~/Desktop//Research 2021-2022")
}
if (getwd()!= "/Users/rebeccawilder/Desktop/Research 2021-2022"){
setwd("/Users/rebeccawilder/Desktop/Research 2021-2022")
}
if (getwd()!= "/Users/rebeccawilder/Desktop/Research 2021-2022"){
setwd("~/Desktop//Research 2021-2022")
}
# install.packages("data.table")
library(data.table)
library(ggplot2)
dat <- data.table(read.csv("snafu_sample.csv"))
(dat <- dat[dat[,group == "Experiment1"]])
dat[listnum<3, listrank:= 1]
dat[listnum>=3 & listnum <6, listrank := 2]
dat[listnum>=6, listrank := 3]
fruit <- dat[category== "fruits"]
veg <- dat[category== "vegetables"]
animal <- dat[category== "animals"]
fruit[listnum<3, listrank:= 1]
fruit[listnum>=3 & listnum <6, listrank := 2]
fruit[listnum>=6, listrank := 3]
t1 = vector(mode= "logical", length= 67)
t2 = vector(mode= "logical", length= 67)
int1t2= vector(mode= "logical", length= 67)
############# HERE IS THE IMPORTANT CORRECTION ################
# What I was doing before and what we did during meeting was just getting the counts for item[i] in listrank== 1 and listrank== 2.  This didn't actually specify that subject[j] was recalling item[i] in *both* trial 1 and 2.  By listing the ids for listranks 1 and 2 respectively, you can use intersect to find the overlapping id's and just grab the length for items recalled in both the first and second fluency trial.
############# SPOTCHECK EXAMPLE  SINGLE ITEM ################
#  # Get counts for rp fluency trial 1
# idl1 <- fruit[listrank== 1 & item== "kiwi"]$id
#  # Get counts for rp fluency trial 2
# idl2 <- fruit[listrank== 2 & item== "kiwi"]$id
# #
# # # Find overlapping id's between trial 1 and 2 for item i
# length(intersect(idl1,idl2))
# This works and adds up correctly
# Grab all items generated from list 2
fruit_items= unique(fruit[listrank== 2,item])
t2t1= vector()
for (i in 1:length(fruit_items)){
# Get counts for rp fluency trial 1
idl1 <- fruit[listrank== 1 & item== fruit_items[i]]$id
# Get counts for rp fluency trial 2
idl2 <- fruit[listrank== 2 & item== fruit_items[i]]$id
# Take the length of overlapping id's between trials 1 & 2 for item i
int1t2[i] <- length(intersect(idl1,idl2))
t2[i] <- sum(fruit[listrank== 2 & item== fruit_items[i], .N, by= id]$N>0)
t2t1[i]= idl2
}
# Super messy, will clean up
sf2= (t2-1)/length(nsubj)
pfruit= data.table()
pfruit[, sf2:= sf2]
pfruit[, sf2sf1:= int1t2/length(t2t1)]
ggplot(data= data.frame(pfruit),aes(x= sf2, y=sf2sf1))+ geom_count(alpha= 0.5)+ geom_abline(slope= 1, intercept= 0)+ geom_smooth(method= "lm")
ggplot(data= data.frame(pfruit), aes(x= sf2, y= sf2sf1))+ geom_point()+ stat_identity(geom= "line" )
# Super messy, will clean up
sf2= (t2-1)/length(nsubj)
pfruit= data.table()
pfruit[, sf2:= sf2]
dat <- data.table(read.csv("snafu_sample.csv"))
(dat <- dat[dat[,group == "Experiment1"]])
dat[listnum<3, listrank:= 1]
dat[listnum>=3 & listnum <6, listrank := 2]
dat[listnum>=6, listrank := 3]
fruit <- dat[category== "fruits"]
veg <- dat[category== "vegetables"]
animal <- dat[category== "animals"]
fruit[listnum<3, listrank:= 1]
fruit[listnum>=3 & listnum <6, listrank := 2]
fruit[listnum>=6, listrank := 3]
t1 = vector(mode= "logical", length= 67)
t2 = vector(mode= "logical", length= 67)
int1t2= vector(mode= "logical", length= 67)
############# HERE IS THE IMPORTANT CORRECTION ################
# What I was doing before and what we did during meeting was just getting the counts for item[i] in listrank== 1 and listrank== 2.  This didn't actually specify that subject[j] was recalling item[i] in *both* trial 1 and 2.  By listing the ids for listranks 1 and 2 respectively, you can use intersect to find the overlapping id's and just grab the length for items recalled in both the first and second fluency trial.
############# SPOTCHECK EXAMPLE  SINGLE ITEM ################
#  # Get counts for rp fluency trial 1
# idl1 <- fruit[listrank== 1 & item== "kiwi"]$id
#  # Get counts for rp fluency trial 2
# idl2 <- fruit[listrank== 2 & item== "kiwi"]$id
# #
# # # Find overlapping id's between trial 1 and 2 for item i
# length(intersect(idl1,idl2))
# This works and adds up correctly
# Grab all items generated from list 2
fruit_items= unique(fruit[listrank== 2,item])
t2t1= vector()
for (i in 1:length(fruit_items)){
# Get counts for rp fluency trial 1
idl1 <- fruit[listrank== 1 & item== fruit_items[i]]$id
# Get counts for rp fluency trial 2
idl2 <- fruit[listrank== 2 & item== fruit_items[i]]$id
# Take the length of overlapping id's between trials 1 & 2 for item i
int1t2[i] <- length(intersect(idl1,idl2))
t2[i] <- sum(fruit[listrank== 2 & item== fruit_items[i], .N, by= id]$N>0)
t2t1[i]= idl2
}
if (getwd()!= "/Users/rebeccawilder/Documents/GitHub/Wilder-Research-ZemlaLab"){
setwd("~/Documents/GitHub/Wilder-Research-ZemlaLab")
}
# Install packages and libraries
# install.packages("data.table")
# install.packages("ggplot2")
# install.packages("cowplot")
# library("cowplot")
library(data.table)
library(ggplot2)
# Load Data
dat <- data.table(read.csv("snafu_sample.csv"))
(dat <- dat[dat[,group == "Experiment1"]]) #Only looking at Experiment 1
# Data Setup
dat[listnum<3, listrank:= 1]
dat[listnum>=3 & listnum <6, listrank := 2]
dat[listnum>=6, listrank := 3]
fruit <- dat[category== "fruits"]
veg <- dat[category== "vegetables"]
animal <- dat[category== "animals"]
# Just looking at Fruit right now but the rest can be added later
fruit[listnum<3, listrank:= 1]
fruit[listnum>=3 & listnum <6, listrank := 2]
fruit[listnum>=6, listrank := 3]
nsubj= unique(dat$id) #Get number of subjects in Experiment 1
############# SPOTCHECK EXAMPLE  SINGLE ITEM ################
#  # Get counts for rp fluency trial 1
# idl1 <- fruit[listrank== 1 & item== "kiwi"]$id
#  # Get counts for rp fluency trial 2
# idl2 <- fruit[listrank== 2 & item== "kiwi"]$id
# #
# # # Find overlapping id's between trial 1 and 2 for item i
# length(intersect(idl1,idl2))
# This works and adds up correctly
##########################  COMPARISON FOR CATEGORY 2 ##########################
# Grab all items generated from list 2
fruit_items= unique(fruit[listrank== 2,item])
sf2 <- vector()
sf2sf1 <- vector()
for (i in 1:length(fruit_items)){
check_foroverlap <- intersect(fruit[listrank==1 & item== fruit_items[i]]$id, fruit[listrank==2 & item== fruit_items[i]]$id)
sf2[i] <- sum(fruit[listrank== 2 & item== fruit_items[i], .N, by= id]$N)-1
if (length(check_foroverlap)>0){
sf2sf1[i] <- length(check_foroverlap)/sum(fruit[listrank== 1 & item== fruit_items[i], .N, by= id]$N)
}else{
sf2sf1[i] <- 0
}
}
pfruit <- data.table()
pfruit[,sf2:= sf2/length(nsubj)]
pfruit[,sf2sf1:= sf2sf1]
##################  REPEAT COMPARISON FOR CATEGORY 2 ####################
veg[listnum<3, listrank:= 1]
veg[listnum>=3 & listnum <6, listrank := 2]
veg[listnum>=6, listrank := 3]
veg_items= unique(veg[listrank== 2,item]) # Get unique items in repeated fluency trial
vf2 <- vector()
vf2vf1 <- vector()
for (i in 1:length(veg_items)){
check_foroverlap <- intersect(veg[listrank==1 & item== veg_items[i]]$id, veg[listrank==2 & item== veg_items[i]]$id)
vf2[i] <- sum(veg[listrank== 2 & item== veg_items[i], .N, by= id]$N)-1
if (length(check_foroverlap)>0){
vf2vf1[i] <- length(check_foroverlap)/sum(veg[listrank== 1 & item== veg_items[i], .N, by= id]$N)
}else{
vf2vf1[i] <- 0
}
}
pveg= data.table()
pveg[, vf2:= vf2/length(nsubj)]
pveg[, vf2vf1:= vf2vf1]
##################  REPEAT COMPARISON FOR CATEGORY 3 ####################
animal[listnum<3, listrank:= 1]
animal[listnum>=3 & listnum <6, listrank := 2]
animal[listnum>=6, listrank := 3]
animal_items= unique(animal[listrank== 2,item]) # Get unique items in repeated fluency trial
af2 <- vector()
af2af1 <- vector()
for (i in 1:length(animal_items)){
check_foroverlap <- intersect(animal[listrank==1 & item== animal_items[i]]$id, animal[listrank==2 & item== animal_items[i]]$id)
af2[i] <- sum(animal[listrank== 2 & item== animal_items[i], .N, by= id]$N)-1
if (length(check_foroverlap)>0){
af2af1[i] <- length(check_foroverlap)/sum(animal[listrank== 1 & item== animal_items[i], .N, by= id]$N)
}else{
af2af1[i] <- 0
}
}
panimal= data.table()
panimal[, af2:= af2/length(nsubj)]
panimal[, af2af1:= af2af1]
#############################  PLOT DATA ################################
ggplot(data= data.frame(pfruit), aes(x= sf2, y= sf2sf1, color= "Fruits"))+ geom_count(alpha= 0.3)+ geom_abline() + labs(x= "Sum(SF2)-1/length(N Subjects)", y= "Sum(SF2 & SF1)/ Sum(SF1)", color= "Category", size= "Frequency")+ geom_count(data= data.frame(pveg), aes(x= vf2, y= vf2vf1, color= "Vegetables"), alpha= 0.3)+ geom_count(data= data.frame(panimal), aes(x= af2, y= af2af1, color= "Animals"), alpha= 0.3)
ggsave("fixed_sfcomparison10032021", device= "png", dpi= 300)
################### Something like an SPC? ###################
#############################  PLOT DATA ################################
ggplot(data= data.frame(pfruit), aes(x= sf2, y= sf2sf1, color= "Fruits"))+ geom_count(alpha= 0.3)+ geom_abline() + labs(x= "Item Frequency Across Subjects", y= "Conditional Probability of Repeating an Item", color= "Category", size= "Frequency")+ geom_count(data= data.frame(pveg), aes(x= vf2, y= vf2vf1, color= "Vegetables"), alpha= 0.3)+ geom_count(data= data.frame(panimal), aes(x= af2, y= af2af1, color= "Animals"), alpha= 0.3)
ggsave("fixed_sfcomparison10032021", device= "png", dpi= 300)
#############################  PLOT DATA ################################
ggplot(data= data.frame(pfruit), aes(x= sf2, y= sf2sf1, color= "Fruits"))+ geom_count(alpha= 0.3)+ geom_abline() + labs(x= "Item Frequency SF2-1", y= "Conditional Probability p(SF1 & SF2)/SF1", color= "Category", size= "Frequency")+ geom_count(data= data.frame(pveg), aes(x= vf2, y= vf2vf1, color= "Vegetables"), alpha= 0.3)+ geom_count(data= data.frame(panimal), aes(x= af2, y= af2af1, color= "Animals"), alpha= 0.3)
ggsave("fixed_sfcomparison10032021", device= "png", dpi= 300)
#############################  PLOT DATA ################################
ggplot(data= data.frame(pfruit), aes(x= sf2, y= sf2sf1, color= "Fruits"))+ geom_count(alpha= 0.3)+ geom_abline() + labs(x= "Item Frequency SF2-1", y= "Conditional Probability p(SF1 & SF2)/SF1", color= "Category", size= "Frequency")+ geom_count(data= data.frame(pveg), aes(x= vf2, y= vf2vf1, color= "Vegetables"), alpha= 0.3)+ geom_count(data= data.frame(panimal), aes(x= af2, y= af2af1, color= "Animals"), alpha= 0.3)
ggsave("fixed_sfcomparison10032021", device= "png", dpi= 300)
#############################  PLOT DATA ################################
ggplot(data= data.frame(pfruit), aes(x= sf2, y= sf2sf1, color= "Fruits"))+ geom_count(alpha= 0.3)+ geom_abline() + labs(x= "Item Frequency (SF2-1)÷N", y= "Conditional Probability p(SF1 & SF2)/SF1", color= "Category", size= "Frequency")+ geom_count(data= data.frame(pveg), aes(x= vf2, y= vf2vf1, color= "Vegetables"), alpha= 0.3)+ geom_count(data= data.frame(panimal), aes(x= af2, y= af2af1, color= "Animals"), alpha= 0.3)
ggsave("fixed_sfcomparison10032021", device= "png", dpi= 300)
#############################  PLOT DATA ################################
ggplot(data= data.frame(pfruit), aes(x= sf2, y= sf2sf1, color= "Fruits"))+ geom_count(alpha= 0.3)+ geom_abline() + labs(x= "Item Frequency (SF2-1)÷N", y= "Conditional Probability p(SF1 & SF2)÷SF1", color= "Category", size= "Frequency")+ geom_count(data= data.frame(pveg), aes(x= vf2, y= vf2vf1, color= "Vegetables"), alpha= 0.3)+ geom_count(data= data.frame(panimal), aes(x= af2, y= af2af1, color= "Animals"), alpha= 0.3)
ggsave("fixed_sfcomparison10032021", device= "png", dpi= 300)
#############################  PLOT DATA ################################
ggplot(data= data.frame(pfruit), aes(x= sf2, y= sf2sf1, color= "Fruits"))+ geom_count(alpha= 0.3)+ geom_abline() + labs(x= "Item Frequency (SF2-1)÷N", y= "Conditional Probability p(SF1 & SF2)÷SF1", color= "Category", size= "Frequency")+ geom_count(data= data.frame(pveg), aes(x= vf2, y= vf2vf1, color= "Vegetables"), alpha= 0.3)+ geom_count(data= data.frame(panimal), aes(x= af2, y= af2af1, color= "Animals"), alpha= 0.3)
ggsave("fixed_sfcomparison10212021", device= "png", dpi= 300)
#############################  PLOT DATA ################################
ggplot(data= data.frame(pfruit), aes(x= sf2, y= sf2sf1, color= "Fruits"))+ geom_count(alpha= 0.3)+ geom_abline() + labs(x= "Item Frequency (SF2-1)÷N", y= "Conditional Probability p(SF1 & SF2)~SF1", color= "Category", size= "Frequency")+ geom_count(data= data.frame(pveg), aes(x= vf2, y= vf2vf1, color= "Vegetables"), alpha= 0.3)+ geom_count(data= data.frame(panimal), aes(x= af2, y= af2af1, color= "Animals"), alpha= 0.3)
ggsave("fixed_sfcomparison10212021", device= "png", dpi= 300)
#############################  PLOT DATA ################################
ggplot(data= data.frame(pfruit), aes(x= sf2, y= sf2sf1, color= "Fruits"))+ geom_count(alpha= 0.3)+ geom_abline() + labs(x= "Typicality p(SF2-1)", y= "Conditional Probability of Repetition p(SF1 & SF2)~SF1", color= "Category", size= "Frequency")+ geom_count(data= data.frame(pveg), aes(x= vf2, y= vf2vf1, color= "Vegetables"), alpha= 0.3)+ geom_count(data= data.frame(panimal), aes(x= af2, y= af2af1, color= "Animals"), alpha= 0.3)
ggsave("fixed_sfcomparison10212021", device= "png", dpi= 300)
25*7
